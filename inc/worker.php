<?php
/**
 *  PlayerUI Copyright (C) 2013 Andrea Coiutti & Simone De Gregori
 *  Tsunamp Team
 *  http://www.tsunamp.com
 *
 *  This Program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3, or (at your option)
 *  any later version.
 *
 *  This Program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with TsunAMP; see the file COPYING.  If not, see
 *  <http://www.gnu.org/licenses/>.
 *
 * Rewrite by Tim Curtis and Andreas Goetz
 */

/**
 * Check if worker available for next task
 */
function workerIsFree() {
	return !(isset($_SESSION['w_lock']) && isset($_SESSION['w_queue']))
		|| $_SESSION['w_lock'] !== 1 && $_SESSION['w_queue'] == '';
}

/**
 * Add task to queue
 */
function workerPushTask($task, $parameters = null) {
	if (!workerIsFree()) {
		return false;
	}

	$_SESSION['w_active'] = 1;
	$_SESSION['w_queue'] = $task;
	$_SESSION['w_queueargs'] = $parameters;

	return true;
}

/**
 * Get task from queue
 */
function workerPopTask($args) {
	if ($task =
		isset($_SESSION['w_active']) && $_SESSION['w_active'] == 1 &&
		isset($_SESSION['w_lock']) && $_SESSION['w_lock'] == 0)
	{
		$_SESSION['w_lock'] = 1;			// lock queue
		$task = $_SESSION['w_queue'];		// get task from queue
		$args = $_SESSION['w_queueargs'];	// get args from queue
	}

	return $task;
}

/**
 * Remove task from queue
 */
function workerFinishTask() {
	$_SESSION['w_active'] = 0;			// mark worker inactive
	$_SESSION['w_lock'] = 0;			// unlock queue
	$_SESSION['w_queue'] = '';			// remove task from queue
	$_SESSION['w_queueargs'] = '';		// remove task from queue
}

function wrk_checkStrSysfile($sysfile,$searchstr) {
	$file = stripcslashes(file_get_contents($sysfile));
	return (strpos($file, $searchstr)) ? true : false;
}

function wrk_mpdconf($kernelver = null, $i2s = null) {
	// extract mpd.conf from SQLite datastore
	ConfigDB::connect();
	$mpdcfg = ConfigDB::read('', 'mpdconf');

	// set mpd.conf file header
	$output =  "#########################################\n";
	$output .= "# This file is automatically generated by\n";
	$output .= "# the Player via MPD Configuration page. \n";
	$output .= "#########################################\n";
	$output .= "\n";

	// parse DB output
	foreach ($mpdcfg as $cfg) {
		if ($cfg['param'] == 'audio_output_format' && $cfg['value_player'] == 'disabled'){
			$output .= '';
		}
		else if ($cfg['param'] == 'dsd_usb') {
			$dsd = $cfg['value_player'];
		}
		else if ($cfg['param'] == 'device') {
			$device = $cfg['value_player'];
			var_export($device);
		}
		else if ($cfg['param'] == 'mixer_type') {
			// store volume mixer type in tcmods.conf
			$_tcmods_conf = getTcmodsConf();
			if ($_tcmods_conf['volume_mixer_type'] != $cfg['value_player']) {
				$_tcmods_conf['volume_mixer_type'] = $cfg['value_player'];
				$rtn = _updTcmodsConf($_tcmods_conf); // update conf file
			}

			// get volume mixer control name
			if ($cfg['value_player'] == 'hardware' ) {
				$hwmixer['control'] = getMixerName($kernelver, $i2s);
			}
			else {
				$output .= $cfg['param']." \"".$cfg['value_player']."\"\n";
			}
		}
		else {
			$output .= $cfg['param']." \"".$cfg['value_player']."\"\n";
		}
	}

	// format audio input / output interfaces
	$output .= <<<EOT
max_connections "20"

decoder {
plugin "ffmpeg"
enabled "yes"
}

input {
plugin "curl"
}

audio_output {
type "alsa"
name "Output"
device "hw:$device,0"
EOT;

	if (isset($hwmixer)) {
		$output .= "mixer_control \"".$hwmixer['control']."\"\n";
		$output .= "mixer_device \"hw:".$device."\"\n";
		$output .= "mixer_index \"0\"\n";
	}

	$output .= "dsd_usb \"".$dsd."\"\n";
	$output .= "}\n";

	// write mpd.conf file
	file_put_contents("/etc/mpd.conf", $output);
}

function wrk_sourcemount($action,$id = null) {
	$return = null;

	switch ($action) {
		case 'mount':
			ConfigDB::connect();
			$mp = ConfigDB::read('cfg_source','',$id);
			sysCmd("mkdir \"/mnt/NAS/".$mp[0]['name']."\"");
			$mountstr = ($mp[0]['type'] == 'cifs')
				// smb/cifs mount
				? "mount -t cifs \"//".$mp[0]['address']."/".$mp[0]['remotedir']."\" -o username=".$mp[0]['username'].",password='".$mp[0]['password']."',rsize=".$mp[0]['rsize'].",wsize=".$mp[0]['wsize'].",iocharset=".$mp[0]['charset'].",".$mp[0]['options']." \"/mnt/NAS/".$mp[0]['name']."\""
				: "mount -t nfs -o ".$mp[0]['options']." \"".$mp[0]['address'].":/".$mp[0]['remotedir']."\" \"/mnt/NAS/".$mp[0]['name']."\"";

			// debug
			error_log(">>>>> mount string >>>>> ".$mountstr,0);
			$sysoutput = sysCmd($mountstr);
			error_log(var_dump($sysoutput),0);
			if (empty($sysoutput)) {
				if (!empty($mp[0]['error'])) {
					$mp[0]['error'] = '';
					ConfigDB::update('cfg_source','',$mp[0]);
				}
				$return = 1;
			}
			else {
				sysCmd("rmdir \"/mnt/NAS/".$mp[0]['name']."\"");
				$mp[0]['error'] = implode("\n",$sysoutput);
				ConfigDB::update('cfg_source','',$mp[0]);
				$return = 0;
			}
			break;

		case 'mountall':
			ConfigDB::connect();
			$mounts = ConfigDB::read('cfg_source');
			foreach ($mounts as $mp) {
				if (!wrk_checkStrSysfile('/proc/mounts',$mp['name']) ) {
					$return = wrk_sourcemount('mount',$mp['id']);
				}
			}

			break;
	}
	return $return;
}

function wrk_sourcecfg($queueargs) {
	$action = $queueargs['mount']['action'];
	unset($queueargs['mount']['action']);
	switch ($action) {
		case 'reset':
			ConfigDB::connect();
			$source = ConfigDB::read('cfg_source');
				foreach ($source as $mp) {
					sysCmd("umount -f \"/mnt/NAS/".$mp['name']."\"");
					sysCmd("rmdir \"/mnt/NAS/".$mp['name']."\"");
				}
			$return = (ConfigDB::delete('cfg_source')) ? 1 : 0;

			break;

		case 'add':
			ConfigDB::connect();
			print_r($queueargs);
			unset($queueargs['mount']['id']);

			// write new entry
			$newmountID = ConfigDB::write('cfg_source', array_values($queueargs['mount']));

			$return = wrk_sourcemount('mount', $newmountID) ? 1 : 0;
			break;

		case 'edit':
			ConfigDB::connect();
			$mp = ConfigDB::read('cfg_source','',$queueargs['mount']['id']);
			ConfigDB::update('cfg_source','',$queueargs['mount']);
			sysCmd("umount -f \"/mnt/NAS/".$mp[0]['name']."\"");

			if ($mp[0]['name'] != $queueargs['mount']['name']) {
				sysCmd("rmdir \"/mnt/NAS/".$mp[0]['name']."\"");
				sysCmd("mkdir \"/mnt/NAS/".$queueargs['mount']['name']."\"");
			}

			$return = (wrk_sourcemount('mount',$queueargs['mount']['id'])) ? 1 : 0;
			error_log(">>>>> wrk_sourcecfg(edit) exit status = >>>>> ".$return, 0);
			break;

		case 'delete':
			ConfigDB::connect();
			$mp = ConfigDB::read('cfg_source','',$queueargs['mount']['id']);
			sysCmd("umount -f \"/mnt/NAS/".$mp[0]['name']."\"");
			sysCmd("rmdir \"/mnt/NAS/".$mp[0]['name']."\"");
			$return = (ConfigDB::delete('cfg_source',$queueargs['mount']['id'])) ? 1 : 0;
			break;
	}

	return $return;
}

function wrk_getHwPlatform(&$archName) {
	$arch = '--';
	$archName = 'unknown';

	foreach (file('/proc/cpuinfo') as $line) {
		if (substr($line, 0, 8) == 'Hardware') {
			switch (trim(substr($line, 11, 50))) {
				case 'BCM2708':
					$arch = '01';
					$archName = 'RaspberryPi';
					break;
				case 'SECO i.Mx6 UDOO Board':
					$arch = '02';
					$archName = 'UDOO';
					break;
				case 'Marvell Dove (Flattened Device Tree)':
					$arch = '03';
					$archName = 'CuBox';
					break;
				case 'Generic AM33XX (Flattened Device Tree)':
					$arch = '04';
					$archName = 'BeagleBone Black';
					break;
				case 'Compulab CM-FX6':
					$arch = '05';
					$archName = 'Compulab Utilite';
					break;
				case 'Freescale i.MX6 Quad/DualLite (Device Tree)':
					$arch = '06';
					$archName = 'Wandboard';
					break;
			}
		}
	}

	return $arch;
}

function wrk_playerID($arch) {
	return $arch.md5_file('/sys/class/net/eth0/address');
}

function wrk_sysChmod() {
	sysCmd('chmod -R 777 /var/www/db');
	sysCmd('chmod a+x /var/www/command/orion_optimize.sh');
	sysCmd('chmod a+x /var/www/command/unmute.sh');
	sysCmd('chmod 777 /run');
	sysCmd('chmod 777 /run/sess*');
	sysCmd('chmod a+rw /etc/mpd.conf');
}
