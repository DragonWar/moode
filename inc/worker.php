<?php
/**
 *  PlayerUI Copyright (C) 2013 Andrea Coiutti & Simone De Gregori
 *  Tsunamp Team
 *  http://www.tsunamp.com
 *
 *  This Program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3, or (at your option)
 *  any later version.
 *
 *  This Program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with TsunAMP; see the file COPYING.  If not, see
 *  <http://www.gnu.org/licenses/>.
 *
 * Rewrite by Tim Curtis and Andreas Goetz
 */

/**
 * Check if worker available for next task
 */
function workerIsFree() {
	return !(isset($_SESSION['w_lock']) && isset($_SESSION['w_queue']))
		|| $_SESSION['w_lock'] !== 1 && $_SESSION['w_queue'] == '';
}

/**
 * Add task to queue
 */
function workerPushTask($task, $args = null) {
	if (!workerIsFree()) {
		return false;
	}

	$_SESSION['w_active'] = 1;
	$_SESSION['w_queue'] = $task;
	$_SESSION['w_queueargs'] = $args;

	return true;
}

/**
 * Get task from queue
 */
function workerPopTask(&$args) {
	if ($task =
		isset($_SESSION['w_active']) && $_SESSION['w_active'] == 1 &&
		isset($_SESSION['w_lock']) && $_SESSION['w_lock'] == 0)
	{
		$_SESSION['w_lock'] = 1;			// lock queue
		$task = $_SESSION['w_queue'];		// get task from queue
		$args = $_SESSION['w_queueargs'];	// get args from queue
	}

	return $task;
}

/**
 * Remove task from queue
 */
function workerFinishTask() {
	$_SESSION['w_active'] = 0;			// mark worker inactive
	$_SESSION['w_lock'] = 0;			// unlock queue
	$_SESSION['w_queue'] = '';			// remove task from queue
	$_SESSION['w_queueargs'] = '';		// remove task from queue
}

function wrk_checkStrSysfile($sysfile,$searchstr) {
	$file = stripcslashes(file_get_contents($sysfile));
	return (strpos($file, $searchstr)) ? true : false;
}

function wrk_mpdconf($kernelver = null, $i2s = null) {
	// extract mpd.conf from SQLite datastore
	$_tcmods_conf = getTcmodsConf();

	// $mpdcfg = ConfigDB::read('', 'mpdconf');
	$mpdcfg = array_column(ConfigDB::read('', 'mpdconf'), 'value_player', 'param');

	// set mpd.conf file header
	$output =  "#########################################\n";
	$output .= "# This file is automatically generated by\n";
	$output .= "# the Player via MPD Configuration page. \n";
	$output .= "#########################################\n";
	$output .= "\n";

	foreach ($mpdcfg as $key => $val) {
		switch ($key) {
			// supress
			case 'dsd_usb':
				break;

			case 'device':
				$device = $val;
				break;

			case 'mixer_type':
				// get volume mixer control name
				if ('hardware' == ($mixer_type = $mpdcfg['mixer_type'])) {
					$hwmixer = getMixerName($kernelver, $i2s);
					break;
				}
				// fallthrough - output mixer_type
			default:
				// don't output disabled audio_output_format
				if ($key !== 'audio_output_format' || $val !== 'disabled') {
					$output .= $key . " \"" . $val . "\"\n";
				}
		}
	}

	// format audio input / output interfaces
	$output .= <<<EOT
max_connections "20"

decoder {
plugin "ffmpeg"
enabled "yes"
}

input {
plugin "curl"
}

audio_output {
type "alsa"
name "Output"
device "hw:$device,0"

EOT;

	if (isset($hwmixer)) {
		$output .= "mixer_control \"" . $hwmixer . "\"\n";
		$output .= "mixer_device \"hw:" . $device . "\"\n";
		$output .= "mixer_index \"0\"\n";
	}

	$output .= "dsd_usb \"" . $mpdcfg['dsd_usb'] . "\"\n";
	$output .= "}\n";

	// write mpd.conf file
	file_put_contents("/etc/mpd.conf", $output);

	// store volume mixer type in tcmods.conf
	if ($_tcmods_conf['volume_mixer_type'] != $mixer_type) {
		$_tcmods_conf['volume_mixer_type'] = $mixer_type;
		_updTcmodsConf($_tcmods_conf);
	}
}

function wrk_sourcemount($action,$id = null) {
	$return = null;

	switch ($action) {
		case 'mount':
			$mp = ConfigDB::read('cfg_source','',$id);

			sysCmd("mkdir \"/mnt/NAS/".$mp[0]['name']."\"");
			$mountstr = ($mp[0]['type'] == 'cifs')
				// smb/cifs mount
				? "mount -t cifs \"//".$mp[0]['address']."/".$mp[0]['remotedir']."\" -o username=".$mp[0]['username'].",password='".$mp[0]['password']."',rsize=".$mp[0]['rsize'].",wsize=".$mp[0]['wsize'].",iocharset=".$mp[0]['charset'].",".$mp[0]['options']." \"/mnt/NAS/".$mp[0]['name']."\""
				: "mount -t nfs -o ".$mp[0]['options']." \"".$mp[0]['address'].":/".$mp[0]['remotedir']."\" \"/mnt/NAS/".$mp[0]['name']."\"";

			// debug
			error_log(">>>>> mount string >>>>> ".$mountstr,0);
			$sysoutput = sysCmd($mountstr);
			error_log(var_dump($sysoutput),0);
			if (empty($sysoutput)) {
				if (!empty($mp[0]['error'])) {
					$mp[0]['error'] = '';
					ConfigDB::update('cfg_source','',$mp[0]);
				}
				$return = 1;
			}
			else {
				sysCmd("rmdir \"/mnt/NAS/".$mp[0]['name']."\"");
				$mp[0]['error'] = implode("\n",$sysoutput);
				ConfigDB::update('cfg_source','',$mp[0]);
				$return = 0;
			}
			break;

		case 'mountall':
			$mounts = ConfigDB::read('cfg_source');

			foreach ($mounts as $mp) {
				if (!wrk_checkStrSysfile('/proc/mounts',$mp['name']) ) {
					$return = wrk_sourcemount('mount',$mp['id']);
				}
			}

			break;
	}
	return $return;
}

function wrk_sourcecfg($queueargs) {
	$action = $queueargs['mount']['action'];
	unset($queueargs['mount']['action']);
	switch ($action) {
		case 'reset':
			$source = ConfigDB::read('cfg_source');

			foreach ($source as $mp) {
				sysCmd("umount -f \"/mnt/NAS/".$mp['name']."\"");
				sysCmd("rmdir \"/mnt/NAS/".$mp['name']."\"");
			}

			$return = (ConfigDB::delete('cfg_source')) ? 1 : 0;

			break;

		case 'add':
			print_r($queueargs);
			unset($queueargs['mount']['id']);

			// write new entry
			$newmountID = ConfigDB::write('cfg_source', array_values($queueargs['mount']));

			$return = wrk_sourcemount('mount', $newmountID) ? 1 : 0;
			break;

		case 'edit':
			$mp = ConfigDB::read('cfg_source','',$queueargs['mount']['id']);
			ConfigDB::update('cfg_source','',$queueargs['mount']);
			sysCmd("umount -f \"/mnt/NAS/".$mp[0]['name']."\"");

			if ($mp[0]['name'] != $queueargs['mount']['name']) {
				sysCmd("rmdir \"/mnt/NAS/".$mp[0]['name']."\"");
				sysCmd("mkdir \"/mnt/NAS/".$queueargs['mount']['name']."\"");
			}

			$return = (wrk_sourcemount('mount',$queueargs['mount']['id'])) ? 1 : 0;
			error_log(">>>>> wrk_sourcecfg(edit) exit status = >>>>> ".$return, 0);
			break;

		case 'delete':
			$mp = ConfigDB::read('cfg_source','',$queueargs['mount']['id']);
			sysCmd("umount -f \"/mnt/NAS/".$mp[0]['name']."\"");
			sysCmd("rmdir \"/mnt/NAS/".$mp[0]['name']."\"");
			$return = (ConfigDB::delete('cfg_source',$queueargs['mount']['id'])) ? 1 : 0;
			break;
	}

	return $return;
}

function wrk_getHwPlatform(&$archName) {
	$arch = '--';
	$archName = 'unknown';

	foreach (file('/proc/cpuinfo') as $line) {
		if (substr($line, 0, 8) == 'Hardware') {
			switch (trim(substr($line, 11, 50))) {
				case 'BCM2708':
					$arch = '01';
					$archName = 'RaspberryPi';
					break;
				case 'SECO i.Mx6 UDOO Board':
					$arch = '02';
					$archName = 'UDOO';
					break;
				case 'Marvell Dove (Flattened Device Tree)':
					$arch = '03';
					$archName = 'CuBox';
					break;
				case 'Generic AM33XX (Flattened Device Tree)':
					$arch = '04';
					$archName = 'BeagleBone Black';
					break;
				case 'Compulab CM-FX6':
					$arch = '05';
					$archName = 'Compulab Utilite';
					break;
				case 'Freescale i.MX6 Quad/DualLite (Device Tree)':
					$arch = '06';
					$archName = 'Wandboard';
					break;
			}
		}
	}

	return $arch;
}

function wrk_playerID($arch) {
	return $arch.md5_file('/sys/class/net/eth0/address');
}

function wrk_sysChmod() {
	sysCmd('chmod -R 777 /var/www/db');
	sysCmd('chmod a+x /var/www/command/orion_optimize.sh');
	sysCmd('chmod a+x /var/www/command/unmute.sh');
	sysCmd('chmod 777 /run');
	sysCmd('chmod 777 /run/sess*');
	sysCmd('chmod a+rw /etc/mpd.conf');
}
